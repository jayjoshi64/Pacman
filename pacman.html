<!-- 
This version is for Pacman movement engine


DONE .!!!!!


Pacman movement engine is working perfect :D


:)
 -->
<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <script src="js/svg.js"></script>
	<script src="js/jquery.min.js"></script>
	<script src="js/jquery.csv.min.js"></script>
	

</head>

<body>
<div  align="center">
  <div class="graph"></div>
</div>

<div class="score"></div>

<script>

var svg = new SVG(document.querySelector(".graph")).size("100%", 600);



function plot(game)
{
	this.game=game;
    this.width=this.game.width;
	this.height=this.game.height;
	this.obst= [];
    this.map= [];
	this.block=[];
	for(var i=0;i<this.height;i++)
	{
		this.map[i]=[];
		this.block[i]=[];
		for(var j=0;j<this.width;j++)
		{
			this.block[i][j]=null;
			if((i==2&&j==2) || (i==6&&j==6))
			{
				this.map[i][j]=true;
				
			}
			else
			{
			this.map[i][j]=false;
			}
		}
	}
	
	
	
	this.border= svg.rect(this.width*blocksize,this.height*blocksize).fill("#ffffff").stroke("#000");
	
	that=this;
	
    $.ajax({
        type: "GET",
        url: "data.txt",
        dataType: "text",
        success: function(data) {
			that.loader=$.csv.toArrays(data);
			that.load();
		}
	 });
	 
	
	this.load=function()
	{
		for(var i=0;i<this.height;i++)
		{
			for(var j=0;j<this.width;j++)
			{
				if(this.loader[i][j]=="1")
				{
					//alert("gotcha");
					this.map[i][j]=true;
				}
				else if(this.loader[i][j]=="0")
				{
					this.map[i][j]=false;
				}
				else
				{
					alert("error : expected 1/0 FOUND :" + this.loader[i][j]);
				}
			}
		}
	
	
	
	
	for(var i=0;i<this.height;i++)
	{
		for(var j=0;j<this.width;j++)
		{
			if(this.map[i][j]==true)
			{
				//alert("gotcha");
				this.block[i][j]=svg.rect(blocksize,blocksize).move(j*blocksize,i*blocksize).fill("#000");
			}
			else
			{
				this.block[i][j]={taken:false,select:null};
				this.block[i][j].select=svg.rect(pointsize,pointsize).move((j+0.5)*blocksize-(pointsize/2),(i+0.5)*blocksize-(pointsize/2)).fill("#00ffd2");
			}
		}
	}
	
	if(this.map[this.game.pacman.location.y][this.game.pacman.location.x]==false)
	{
		//alert(this.plot.block[0][0]);
		this.block[this.game.pacman.location.y][this.game.pacman.location.x].taken=true;
		this.block[this.game.pacman.location.y][this.game.pacman.location.x].select.remove();
	}
	
	}
	

	this.canimove = function(location,direction,thepacc)
	{
		
		var diffx = 0;
		var diffy = 0;
		
		if(direction == 1 )
		{
			diffx = -1;
		}
		else if(direction == 2)
		{
			diffy = -1;
		}
		else if(direction == 3)
		{
			diffx = 1;
		}
		else if(direction == 4)
		{
			diffy= 1;
		}
		else{
			alert("wrong direction : " + direction);
		}
		
		
		var newlocation = {x:location.x+diffx,y:location.y+diffy};
		
		//alert(newlocation.x);
		
		
		if(0<=newlocation.x && newlocation.x < this.width)
		{
			if(0<=newlocation.y && newlocation.y < this.height)
			{
				
				if(!this.map[newlocation.y][newlocation.x])
				{
					thepacc.paused=false;
					var diff={x:diffx,y:diffy};
					thepacc.currentdirection=direction;
					return diff;
				}
			}
		}
		
		
		var diff={x:0,y:0};
		if(thepacc.currentdirection != direction)
		{
			if(thepacc.paused==false)
			{
				//alert("yes");
				diff=this.canimove(location,thepacc.currentdirection,thepacc);
			}
			else
			{
				thepacc.currentdirection=direction;
			}
		}
		else
		{
			//thepacc.currentdirection=0;
			thepacc.paused=true;
			thepacc.select.stop();
			thepacc.init=true;	
			//alert("paused");
		}
		
		
		
		
		return diff;
		
		
		
	}
	
}


function pacman(game)
{
	this.game=game;
	this.time=300;
	this.plot=this.game.plot;
	this.paused=false; // not moving
	this.init=true;
	this.select=svg.circle(blocksize).x(0).y(0).fill("#ffff00").stroke("#000");
	this.state=true; //TRUE -> alive   FALSE ->dead
	this.location = {x:parseInt(this.game.pacx),y:parseInt(this.game.pacy)};
	//alert(this.location.x + " : "+this.location.y);
	this.movedirection=0;
	this.currentdirection=0;
	
	//this.print=Math.floor(Math.random()*100);
	
	
	
	
	/*this.move=function(e,that=this)
	{
		alert(that.print);
	}*/
	
	this.backrun= function(direction)
	{
		var pos = {x:0,y:0};
		pos.x= this.select.x();
		pos.y= this.select.y();
		
		//alert(pos.x + " : "+pos.y);
		if(direction== 1 || direction == 3 )
		{
			//alert( pos.x+" : "+this.plot.size * blocksize);
			if(this.paused==true)
			{
				this.time=300;
				return;
			}
			var diffx = pos.x % blocksize;
			
			if(diffx==0)
			{
				this.time=1;
				return;
			}
			
			if(direction == 1)
			{
				diffx= blocksize - diffx;
			}
			
			
			
			
			
			this.time = (300*diffx)/blocksize;
			if(this.time<0)
			{
				this.time = this.time * (-1);
			}
		}
		else if(direction == 2 || direction == 4)
		{
			
			if(this.paused==true)
			{
				this.time=300;
				return;
			}
			var diffy = pos.y % blocksize;
			if(diffy==0)
			{
				this.time=1;
				return;
			}
			
			if(direction == 2)
			{
				diffy= blocksize - diffy;
			}
			this.time = (300*diffy)/blocksize;
			if(this.time<0)
			{
				this.time=this.time * (-1);
			}
		}
		//alert(this.time);
		return true;
	}
	
	
	$(document).on("keypress",function(e,that=pacman)
	{
			that.time=300;
			var flag=false;
			//alert(that.print);
			if(e.keyCode==37)
			{
				//alert("left");
				flag=true;
				if(that.currentdirection==3)
				{
					that.backrun(that.currentdirection);
					that.init=true;
					that.select.stop();
					
				}
				if(that.currentdirection!=1)
				{
					that.movedirection=1;
				}
		}
			else if(e.keyCode==38)
			{
				//alert("up");
				flag=true;
				if(that.currentdirection==4)
				{
					that.backrun(that.currentdirection);
					that.init=true;
					that.select.stop();
				}
				if(that.currentdirection!=2)
				{
					that.movedirection=2;
				}
			}
			else if(e.keyCode==39)
			{
				//alert("right");
				flag=true;
				if(that.currentdirection==1)
				{
					
					that.backrun(that.currentdirection);
					that.init=true;
					that.select.stop();
					
				}
				if(that.currentdirection!=3)
				{
					that.movedirection=3;
				}
			}
			else if(e.keyCode==40)
			{
				//alert("down");
				flag=true;
				if(that.currentdirection==2)
				{
					that.backrun(that.currentdirection);
					that.init=true;
					that.select.stop();
					
				}
				if(that.currentdirection!=4)
				{
					that.movedirection=4;
				}
			}
			
			if(flag==false)
			{
				return;
			}
			
			if(that.paused==true)
			{
				that.paused=false;
				that.select.stop();
				that.init=true;
			}
			
			that.controller();		
	});
	
	this.controller = function()
	{
		if(this.init==true)
		{
			this.init=false;
			this.animator(this);
		}
	}
	
	
	
	this.animator = function(that)
	{
			//alert(that.location.x);
		var diff=that.plot.canimove(that.location,that.movedirection,that);
			that.location.x+=diff.x;
			that.location.y+=diff.y;
			
			if(that.location.x==that.game.raone.location.x && that.location.y==that.game.raone.location.y)
			{
				alert("game over");
				exit();
			}
			
			that.select.animate(that.time).move((that.location.x)*blocksize,(that.location.y)*blocksize).after(function(){that.time=300;that.animator(that);});
			if(that.plot.block[that.location.y][that.location.x].taken==false)
			{
				that.plot.block[that.location.y][that.location.x].taken=true;
				that.plot.block[that.location.y][that.location.x].select.animate(150).attr({width:0,height:0});
				that.game.player.incscorebyone();
			}
	}

}


function raone(game)
{
	this.game = game;
	this.plot=this.game.plot;
	this.target = this.game.pacman;
	this.location = {x:this.game.width-1,y:this.game.height-1};
	this.skip=false;        // if ( one way is found ..  all streigh - line recursion from that point is skipped) check V2.0 to see diffrence :D
	this.skipx=-1;
	this.skipy=-1;
	this.total=0;  			// count of recursion

	this.found=false;		// to check if selective flooding can find or not
	this.selective=true;  // Selective flooding is on (if true)    //  is off and flooding is done (if false)
	
	this.init=true;
	this.select=svg.circle(blocksize).x(this.location.x*this.game.blocksize).y(this.location.y*this.game.blocksize).fill("red").stroke("#000");
	
	
	/*
			WAY
			----------
			0 - > Start * Should go to all 4 directions
			1 - > Left
			2 - > UP
			3 - > Right
			4 - > Down
			----------
	*/
	
	this.calculatemin = function(node,stack,distance,way)
	{
		this.total++;
		/*
		var waystring="";
		if(way==1)
		{
			waystring="left";
		}
		else if(way==2)
		{
			waystring="up";
		}
		else if(way==3)
		{
			waystring="right";
		}
		else if(way==4)
		{
			waystring="down";
		}
		else{
			waystring="init";
		}
		this.high=svg.rect(blocksize,blocksize).move(node.x*blocksize,node.y*blocksize).fill("yellow");
		alert(node.x+":"+node.y + "   ["+distance+"]  ["+waystring+"]");
		this.high.remove();
		*/
		var flag=false;
		if(this.memory.dist[node.y][node.x] == 0)
		{
			this.memory.dist[node.y][node.x]  = distance + 1;
			//alert(this.memory.dist[node.y][node.x]+" : "+raone.memory.dist[node.y][node.x])
			flag=true;
		}
		else if(this.memory.dist[node.y][node.x] > distance + 1)
		{
		
			this.memory.dist[node.y][node.x]  = distance + 1;
			flag=true;
		
		}
		else if(this.memory.dist[node.y][node.x] < distance + 1)
		{
			//alert(node.x + " : "+node.y  + " -> " + distance + " (way:"+way+")");
			
			return;
			
		}
		else if(this.memory.dist[node.y][node.x] == distance + 1)
		{
		
			
			var diffx = this.location.x - this.target.location.x;
			if(diffx < 0)
			{
				diffx = diffx * (-1);
			}
			var diffy = this.location.y - this.target.location.y;
			if(diffy < 0)
			{
				diffy = diffy * (-1);
			}
			
			
			
			if(diffx > diffy)
			{
				var tempnode = stack[stack.length - 1];
				if(tempnode.x - node.x == 1 || tempnode.x - node.x == -1)
				{
					flag =false;
				}
				else if(tempnode.y - node.y == 1 || tempnode.y - node.y == -1)
				{
					flag=true;
				}
				else
				{
					alert("error : stack(last) : node   - doesnt match");
				}
			}
			else if(diffx < diffy)
			{
				var tempnode = stack[stack.length - 1];
				if(tempnode.x - node.x == 1 || tempnode.x - node.x == -1)
				{
					flag =true;
				}
				else if(tempnode.y - node.y == 1 || tempnode.y - node.y == -1)
				{
					flag=false;
				}
				else
				{
					alert("error : stack(last) : node   - doesnt match");
				}
			}
			else if(diffx == diffy)
			{
				
				if(Math.floor(Math.random() * 2) == 0)
				{
					flag=true;
				}
				else
				{
					flag=false;
				}
			}
			else
			{
				alert("error  inpossible error");
			}
		
		}else
		{
			alert("wow");
		}
		
		var newstack = JSON.stringify(stack);
		newstack = JSON.parse(newstack);
		
		//newstack.add(true);
		//alert(newstack.length);
		
		if(flag==true)
		{
			
			newstack.push(node);
			
			if(node.x == this.target.location.x && node.y == this.target.location.y)
			{
				//alert("done");
				this.found=true;
				this.skip=true;
				this.skipx=node.x;
				this.skipy=node.y;
				this.memory.stack=JSON.stringify(newstack);
				this.memory.stack=JSON.parse(this.memory.stack);
				return;
			}
			
			
		//	this.memory.dist[node.y][node.x];
			var check = function(newnode)
			{
				
				if(0<=newnode.x && newnode.x < raone.game.width)
				{
					if(0<=newnode.y && newnode.y < raone.game.height)
					{
						
						if(!raone.game.plot.map[newnode.y][newnode.x])
						{
							return true;
						}
					}
				}
				return false;
				
			}
		
			var left = function()
			{
				var newnode = JSON.stringify(node);
				newnode = JSON.parse(newnode);
			
				
				newnode.x = newnode.x -1;
				if(check(newnode))
				{
					if(raone.selective==true)
					{
						if(raone.location.x > raone.target.location.x)
						{
							raone.calculatemin(newnode,newstack,raone.memory.dist[node.y][node.x],1);
						
						}
					}
					else
					{
						raone.calculatemin(newnode,newstack,raone.memory.dist[node.y][node.x],1);
					}
					
					
					
					
				}
			}
			var up = function()
			{
				var newnode = JSON.stringify(node);
				newnode = JSON.parse(newnode);
			
				
				newnode.y = newnode.y -1;
				
				if(check(newnode))
				{
					if(raone.selective==true)
					{
						if(raone.location.y > raone.target.location.y)
						{
							raone.calculatemin(newnode,newstack,raone.memory.dist[node.y][node.x],2);
						}
					}
					else
					{
						
						raone.calculatemin(newnode,newstack,raone.memory.dist[node.y][node.x],2);
					}
				}
			}
			
			var right = function()
			{
				var newnode = JSON.stringify(node);
				newnode = JSON.parse(newnode);
			
				newnode.x = newnode.x +1;
				if(check(newnode))
				{
					if(raone.selective==true)
					{
						if(raone.location.x<raone.target.location.x)
						{
							raone.calculatemin(newnode,newstack,raone.memory.dist[node.y][node.x],3);
						}
					}
					else
					{
						
						raone.calculatemin(newnode,newstack,raone.memory.dist[node.y][node.x],3);
					
					}
				}
			}

			var down = function()
			{
				var newnode = JSON.stringify(node);
				newnode = JSON.parse(newnode);
			
				newnode.y = newnode.y +1;
				if(check(newnode))
				{
					if(raone.selective==true)
					{
						if(raone.location.y<raone.target.location.y)
						{
							raone.calculatemin(newnode,newstack,raone.memory.dist[node.y][node.x],4);
						}
					}
					else
					{
						raone.calculatemin(newnode,newstack,raone.memory.dist[node.y][node.x],4);
					}
				}
			}
			
			
			
			
			if(way==0)
			{
				up();
				if(node.x!=this.skipx && node.y!=this.skipy)
				{
						this.skip=false;
				}
				if(this.skip==false)
				{
					right();
					down();
					left();
				}
				else
				{
					
				}
			}
			else if(way==1)
			{
				left();
				if(node.x!=this.skipx && node.y!=this.skipy)
				{
						this.skip=false;
				}
				if(this.skip==false)
				{
					up();
					down();
				}
				else
				{
					
				}
			}
			else if(way==2)
			{
				up();
				if(node.x!=this.skipx && node.y!=this.skipy)
				{
						this.skip=false;
				}
				if(this.skip==false)
				{
					left();
					right();
				}
				else
				{
					
				}
			}
			else if(way==3)
			{
				right();
				if(node.x!=this.skipx && node.y!=this.skipy)
				{
						this.skip=false;
				}
				if(this.skip==false)
				{
				up();
				down();
				}
				else
				{
					
				}
			}
			else if(way==4)
			{
				down();
				if(node.x!=this.skipx && node.y!=this.skipy)
				{
						this.skip=false;
				}
				if(this.skip==false)
				{
					left();
					right();
				}
				else
				{
					
				}
			}
			else
			{
				alert("error : unexpected way, should be 0<=way<=4");
			}
			
		
		
		}
		
		
	}
	
	
	this.animator = function(direction)
	{
			//alert(that.location.x);
		var diff=this.plot.canimove(this.location,direction,this);
			this.location.x+=diff.x;
			this.location.y+=diff.y;
			
			if(this.location.x==this.game.pacman.location.x && this.location.y==this.game.pacman.location.y)
			{
				alert("game over");
				exit();
			}
			
			this.select.animate(300).move((this.location.x)*blocksize,(this.location.y)*blocksize).after(function(){raone.cpu();});
			
			/*if(that.plot.block[that.location.y][that.location.x].taken==false)
			{
				that.plot.block[that.location.y][that.location.x].taken=true;
				that.plot.block[that.location.y][that.location.x].select.animate(150).attr({width:0,height:0});
				that.game.player.incscorebyone();
			}*/
	}
	
	this.cpu = function()
	{
	
		
			this.init=false;
			this.memory = {stack:[],dist:null};
			this.memory.dist = [];
			for(var i=0;i<this.game.height;i++)
			{
				this.memory.dist[i]=[];
				for(var j=0;j<this.game.width;j++)
				{
					this.memory.dist[i][j]=0;
				}
			}
			
		
		
		this.calculatemin(this.location,this.memory.stack,this.memory.dist[this.location.y][this.location.x] , 0);
		
		if(this.found==false)
		{
			//alert("yes");
			this.selective=false;
			this.calculatemin(this.location,this.memory.stack,this.memory.dist[this.location.y][this.location.x] , 0);
		}

		var direction=0;
		if(this.memory.stack[1].x - this.location.x == 1 && this.memory.stack[1].y - this.location.y == 0)
		{
			direction = 3;
		}
		else if(this.memory.stack[1].x - this.location.x == -1 && this.memory.stack[1].y - this.location.y == 0)
		{
			direction = 1;
		}
		else if(this.memory.stack[1].x - this.location.x == 0 && this.memory.stack[1].y - this.location.y == 1)
		{
			direction = 4;
		}
		else if(this.memory.stack[1].x - this.location.x == 0 && this.memory.stack[1].y - this.location.y == -1)
		{
			direction = 2;
		}
		else
		{
			alert("error");
		}
		this.animator(direction);
		var str="";
		this.memory.stack.forEach(function(node)
		{
			str+="-("+node.x+":"+node.y+")";
			//this.high=svg.rect(blocksize,blocksize).move(node.x*blocksize,node.y*blocksize).fill("yellow");
		});
		
		//alert(this.memory.dist[this.target.location.y][this.target.location.x]+" moveto :"+ str + "   ({total:"+this.total+"})");
		
		
		
		
	}
	

	

}

function player()
{
	this.score=0;
	
	this.incscorebyone = function()
	{
			this.score++;
		
		this.showscore();
	}
	this.showscore = function()
	{
		$(".score").html(this.score);
		//alert("gotcha");
	}
	
}

function main()
{
var config;
    $.ajax({
        type: "GET",
        url: "config.txt",
        dataType: "text",
		async: false,
        success: function(data) {
			config=$.csv.toArrays(data);
		}
	 });

width=config[0][1];
height=config[1][1];
blocksize=config[2][1];
pointsize=config[3][1];
this.pacx=config[4][1];
this.pacy=config[5][1];
	
	this.player= new player();
	
	this.plot = new plot(this);
	
	this.pacman = new pacman(this);
	
	this.raone = new raone(this);
	
	
	this.raone.cpu();
}


main();
</script>



</body>

</html>
